---
title: 连接数据库
tags: [asp.net core, 签到系统 V3.0]
category: 寒假实践
author: yiluomyt
time: 2018-01-25
---

## 连接数据库

在前面的小节中，我们通过模拟数据的形式对后台Api进行了测试，而在实际生产环境中，我们往往需要通过数据库来的进行数据的持久化。

我们这里使用的数据库是本地的SQL Server数据库，利用EF Core 作为ORM框架。

## 创建数据库上下文

本节需要引用的名称空间有：
- Microsoft.EntityFrameworkCore
- PFSign.Models

我们所要创建的上下文类型应该继承自默认上下文`DbContext`，并且在其中添加我们的数据集`DbSet<Record> Records`。

(`../Data/RecordDbContext.cs`)
```c#
public class RecordDbContext : DbContext
{
    public DbSet<Record> Records { get; set; }
}
```

## 在Services中添加上下文服务

本节需要引用的名称空间有：
- Microsoft.EntityFrameworkCore
- PFSign.Data

利用Asp.net core 自带的Ioc框架，我们可以很轻松的实现上下文服务的添加。

(`../Startup.cs`)

```c#
public void ConfigureServices(IServiceCollection services)
{
    // 务必在AddMvc之前添加
    services.AddDbContext<RecordDbContext>(
        // 此处配置数据库连接信息
    );
    services.AddMvc();
}
```

之后就是关于数据库连接的配置，由于我们使用的是本地SQL Server数据库，我们先在配置文件中添加连接字符串。

(`../appsettings.json`)

```json
"ConnectionStrings": {
"Local": "Server=(localdb)\\mssqllocaldb;Database=PFSignDev;Trusted_Connection=True;MultipleActiveResultSets=true"
}
```

然后，利用该连接字符串配置数据库连接。

(`../Startup.cs`)

```c#
services.AddDbContext<RecordDbContext>(options
        => options.UseSqlServer(Configuration.GetConnectionString("Local")));
```

最后，利用该配置信息去构造上下文。

(`../Data/RecordDbContext.cs`)

```c#
public class RecordDbContext : DbContext
{
    public RecordDbContext(DbContextOptions<RecordDbContext> options)
        :base(options)
    {}
    // ...
}
```

## 构建数据库

因为是Code-First的设计思路，我们已经在代码中定义好关于数据对象的属性。现在我们利用ef工具，根据我们代码中的定义来创建这个数据库。

首先，添加ef工具。

在`../PFSign.csproj`文件中添加对ef工具的引用。

```xml
<ItemGroup>
  <DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet" Version="2.0.0" />
</ItemGroup>
```

然后打开命令行键入`dotnet restore`导入该工具。

之后，键入`dotnet ef migrations add Init`来生成新的迁移代码。

如下图即生成成功，所生成的代码在`../Migrations`中。

![Add-Migration](https://blog-1252574286.cossh.myqcloud.com/pfstudio/%E7%AD%BE%E5%88%B0%E7%B3%BB%E7%BB%9FV3.0/4-Add-Migration.PNG)

最后，键入`dotnet ef database update`，利用迁移代码创建数据库。

![Update-Database](https://blog-1252574286.cossh.myqcloud.com/pfstudio/%E7%AD%BE%E5%88%B0%E7%B3%BB%E7%BB%9FV3.0/4-Update-Database.PNG)

利用SSMS，我们可以看到ef工具已经帮我们建立对应的数据库以及表。

![数据库表结构](https://blog-1252574286.cossh.myqcloud.com/pfstudio/%E7%AD%BE%E5%88%B0%E7%B3%BB%E7%BB%9FV3.0/4-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84.PNG)

## 注入上下文

这里我们使用构造注入。

(`../Controllers/RecordController.cs`)

```c#
private readonly RecordDbContext _context;

public RecordController(RecordDbContext context)
{
    _context = context;
}
```

之后，我们将原本对于模拟数据集的引用替换为对上下文中数据集的引用，并且改写为异步方法。

部分代码如下：

(`../Controllers/RecordController.cs`)

```c#
// 添加三个名称空间的引用
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using PFSign.Data;

namespace PFSign.Controllers
{
    [Route("/api/[Controller]")]
    public class RecordController
    {
        
        // async标识为异步方法，返回Task的泛型
        public async Task<object> Index
            (DateTime? begin, DateTime? end)
        {
            // ...

            return await (from r in _context.Records
                          // ...
                          select new
                          { // ... }).ToListAsync();
        }

        [HttpPost("[Action]")]
        public async Task<object> SignIn
            (string userId, string name, int seat)
        {
            // ...

            _context.Add(record);
            await _context.SaveChangesAsync();

            // ...
        }

        [HttpPost("[Action]")]
        public async Task<object> SignOut(string userId)
        {
            Record record = await (from r in _context.Records
                                   where r.SignOutTime == null
                                   && r.UserId == userId
                                   select r).FirstOrDefaultAsync();
            
            // ...

            _context.Update(record);
            await _context.SaveChangesAsync();

            // ...
        }
    }
}
```

至此，我们已经完成数据在数据库中持久化的代码。